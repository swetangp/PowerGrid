//MapLoader.cpp
//COMP345 Assignment #1 
//Swetang Patel 03/06/2019
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include "Map.h"
#include "Player.h"
#include "Attributes.h"
#include "Card.h"
#include "soln.h"
#include <algorithm> 
#include <ctime>        
#include <cstdlib>

using namespace std;

int main()
{
	
	//Brand new game of Power Grid without the use of a map loader, this represents the American version
	//The Cities are seperated among many points
	/*City t[42] = {};
	Houses init;
	t[0] = City("Seattle","purple", 10, 15, 20, init); t[1] = City("Portland", "purple", 10, 15, 20, init); t[2] = City("Boise", "purple", 10, 15, 20, init); t[3] = City("Billings", "purple", 10, 15, 20, init); t[4] = City("Cheyenne", "purple", 10, 15, 20, init); t[5] = City("Denver", "purple", 10, 15, 20, init); t[6] = City("Omaha", "purple", 10, 15, 20, init);
	t[7] = City("San Francisco","teal", 10, 15, 20, init); t[8] = City("Salt Lake City", "teal", 10, 15, 20, init); t[9] = City("Las Vegas", "teal", 10, 15, 20, init); t[10] = City("Los Angeles", "teal", 10, 15, 20, init); t[11] = City("San Diego", "teal", 10, 15, 20, init); t[12] = City("Phoenix", "teal", 10, 15, 20, init); t[13] = City("Santa Fe", "teal", 10, 15, 20, init);
	t[14] = City("Kansas City","red", 10, 15, 20, init); t[15] = City("Oklahoma City", "red", 10, 15, 20, init); t[16] = City("Dallas", "red", 10, 15, 20, init); t[17] = City("Houston", "red", 10, 15, 20, init); t[18] = City("Memphis", "red", 10, 15, 20, init); t[19] = City("New Orleans", "red", 10, 15, 20, init); t[20] = City("Birmingham", "red", 10, 15, 20, init);
	t[21] = City("Atlanta","green", 10, 15, 20, init); t[22] = City("Norfolk", "green", 10, 15, 20, init); t[23] = City("Raleigh", "green", 10, 15, 20, init); t[24] = City("Savannah", "green", 10, 15, 20, init); t[25] = City("Jacksonville", "green", 10, 15, 20, init); t[26] = City("Tampa", "green", 10, 15, 20, init); t[27] = City("Miami", "green", 10, 15, 20, init);
	t[28] = City("Boston","brown", 10, 15, 20, init); t[29] = City("New York", "brown", 10, 15, 20, init); t[30] = City("Philadelphia", "brown", 10, 15, 20, init); t[31] = City("Washington", "brown", 10, 15, 20, init); t[32] = City("Buffalo", "brown", 10, 15, 20, init); t[33] = City("Pittsburgh", "brown", 10, 15, 20, init); t[34] = City("Detroit", "brown", 10, 15, 20, init);
	t[35] = City("Fargo","yellow", 10, 15, 20, init); t[36] = City("Duluth", "yellow", 10, 15, 20, init); t[37] = City("Minneapolis", "yellow", 10, 15, 20, init); t[38] = City("Chicago", "yellow", 10, 15, 20, init); t[39] = City("St.Louis", "yellow", 10, 15, 20, init); t[40] = City("Cincinatti", "yellow", 10, 15, 20, init); t[41] = City("Knoxville", "yellow", 10, 15, 20, init);

	//Create a map in which the cities can be placed
	Map PowerGrid;
	City* tp[42];
	for (int i = 0; i < 42; i++)
	{
		tp[i] = &t[i];
	}
	//The cities are then connected to each other with the use of edges and nodes
	t[0].createConnection(tp[1], 3);t[0].createConnection(tp[2], 12);t[0].createConnection(tp[3], 9);
	t[1].createConnection(tp[0], 3);t[1].createConnection(tp[2], 13);t[1].createConnection(tp[7], 24);
	t[2].createConnection(tp[0], 12);t[2].createConnection(tp[1], 13);t[2].createConnection(tp[3], 12);t[2].createConnection(tp[4], 24);t[2].createConnection(tp[7], 23);
	t[3].createConnection(tp[0], 9);t[3].createConnection(tp[2], 12);t[3].createConnection(tp[4], 9);t[3].createConnection(tp[35], 17);t[3].createConnection(tp[37], 18);
	t[4].createConnection(tp[2], 24);t[4].createConnection(tp[3], 9);t[4].createConnection(tp[5], 0);t[4].createConnection(tp[37], 18);t[4].createConnection(tp[6], 14);
	t[5].createConnection(tp[4], 0);t[5].createConnection(tp[8], 21);t[5].createConnection(tp[13], 13);t[5].createConnection(tp[14], 16);
	t[6].createConnection(tp[4], 14);t[6].createConnection(tp[37], 8);t[6].createConnection(tp[38], 13);t[6].createConnection(tp[14], 5);

	t[7].createConnection(tp[1], 24);t[7].createConnection(tp[2], 23);t[7].createConnection(tp[8], 27);t[7].createConnection(tp[9], 14);t[7].createConnection(tp[10], 9);
	t[8].createConnection(tp[2], 8);t[8].createConnection(tp[7], 27);t[8].createConnection(tp[9], 18);t[8].createConnection(tp[13], 28);t[8].createConnection(tp[5], 21);
	t[9].createConnection(tp[7], 14);t[9].createConnection(tp[8], 18);t[9].createConnection(tp[10], 9);t[9].createConnection(tp[11], 9);t[9].createConnection(tp[12], 15);t[9].createConnection(tp[13], 27);
	t[10].createConnection(tp[7], 9);t[10].createConnection(tp[9], 9);t[10].createConnection(tp[11], 3);
	t[11].createConnection(tp[10], 3);t[11].createConnection(tp[9], 9);t[11].createConnection(tp[12], 14);
	t[12].createConnection(tp[11], 14);t[12].createConnection(tp[9], 15);t[12].createConnection(tp[13], 18);
	t[13].createConnection(tp[12], 18);t[13].createConnection(tp[9], 27);t[13].createConnection(tp[8], 28);t[13].createConnection(tp[5], 13);t[13].createConnection(tp[14], 16);t[13].createConnection(tp[15], 15);t[13].createConnection(tp[16], 16);t[13].createConnection(tp[17], 21);

	t[14].createConnection(tp[5], 16);t[14].createConnection(tp[6], 5);t[14].createConnection(tp[13], 16);t[14].createConnection(tp[15], 8);t[14].createConnection(tp[18], 12);t[14].createConnection(tp[39], 6);t[14].createConnection(tp[38], 8);
	t[15].createConnection(tp[14], 8);t[15].createConnection(tp[13], 15);t[15].createConnection(tp[16], 3);t[15].createConnection(tp[18], 14);
	t[16].createConnection(tp[15], 3);t[16].createConnection(tp[13], 16);t[16].createConnection(tp[17], 5);t[16].createConnection(tp[19], 12);t[16].createConnection(tp[18], 12);
	t[17].createConnection(tp[13], 21);t[17].createConnection(tp[16], 5);t[17].createConnection(tp[19], 8);
	t[18].createConnection(tp[14], 12);t[18].createConnection(tp[15], 14);t[18].createConnection(tp[16], 12);t[18].createConnection(tp[19], 7);t[18].createConnection(tp[20], 6);t[18].createConnection(tp[39], 7);
	t[19].createConnection(tp[18], 7);t[19].createConnection(tp[16], 12);t[19].createConnection(tp[17], 8);t[19].createConnection(tp[20], 11);t[19].createConnection(tp[25], 16);
	t[20].createConnection(tp[19], 11);t[20].createConnection(tp[18], 6);t[20].createConnection(tp[25], 9);t[20].createConnection(tp[21], 3);

	t[21].createConnection(tp[20], 3);t[21].createConnection(tp[41], 5);t[21].createConnection(tp[23], 7);t[21].createConnection(tp[24], 7);
	t[22].createConnection(tp[31], 5);t[22].createConnection(tp[23], 3);
	t[23].createConnection(tp[21], 3);t[23].createConnection(tp[33], 7);t[23].createConnection(tp[40], 15);t[23].createConnection(tp[21], 7);t[23].createConnection(tp[24], 7);
	t[24].createConnection(tp[21], 7);t[24].createConnection(tp[23], 7);t[24].createConnection(tp[25], 0);
	t[25].createConnection(tp[24], 0);t[25].createConnection(tp[20], 9);t[25].createConnection(tp[19], 16);t[25].createConnection(tp[26], 4);
	t[26].createConnection(tp[25], 4);t[26].createConnection(tp[27], 4);
	t[27].createConnection(tp[26], 4);

	t[28].createConnection(tp[29], 3);
	t[29].createConnection(tp[28], 3);t[29].createConnection(tp[30], 0);t[29].createConnection(tp[32], 8);
	t[30].createConnection(tp[29], 0);t[30].createConnection(tp[31], 3);
	t[31].createConnection(tp[30], 3);t[31].createConnection(tp[22], 5);t[31].createConnection(tp[33], 6);
	t[32].createConnection(tp[29], 8);t[32].createConnection(tp[33], 7);t[32].createConnection(tp[34], 7);
	t[33].createConnection(tp[32], 7);t[33].createConnection(tp[31], 6);t[33].createConnection(tp[23], 7);t[33].createConnection(tp[40], 7);t[33].createConnection(tp[34], 6);
	t[34].createConnection(tp[32], 7);t[34].createConnection(tp[33], 6);t[34].createConnection(tp[38], 7);t[34].createConnection(tp[40], 4);t[34].createConnection(tp[36], 15);

	t[35].createConnection(tp[3], 17);t[35].createConnection(tp[36], 6);t[35].createConnection(tp[37], 6);
	t[36].createConnection(tp[35], 6);t[36].createConnection(tp[37], 5);t[36].createConnection(tp[38], 12);t[36].createConnection(tp[34], 15);
	t[37].createConnection(tp[36], 5);t[37].createConnection(tp[35], 6);t[37].createConnection(tp[3], 18);t[37].createConnection(tp[4], 18);t[37].createConnection(tp[6], 8);t[37].createConnection(tp[38], 6);
	t[38].createConnection(tp[36], 12);t[38].createConnection(tp[37], 8);t[38].createConnection(tp[6], 13);t[38].createConnection(tp[14], 8);t[38].createConnection(tp[39], 10);t[38].createConnection(tp[40], 7);t[38].createConnection(tp[34], 7);
	t[39].createConnection(tp[38], 10);t[39].createConnection(tp[14], 6);t[39].createConnection(tp[18], 7);t[39].createConnection(tp[21], 12);t[39].createConnection(tp[40], 12);
	t[40].createConnection(tp[39], 12);t[40].createConnection(tp[38], 7);t[40].createConnection(tp[34], 4);t[40].createConnection(tp[33], 7);t[40].createConnection(tp[23], 15);t[40].createConnection(tp[41], 6);
	t[41].createConnection(tp[40], 6);t[41].createConnection(tp[21], 5);

	//The cities are connected appropriately and placed onto the map
	for (int j = 0; j < 42; j++)
	{
		PowerGrid.create(tp[j]);
	}*/
	string inputFile = "Cities.txt";
	const int size = 1000;
	Houses h;
	int count = 0;
	int loadTime = 0;
	int esc = 0;
	ifstream sizeOfArray(inputFile);
	vector<string> arraySize;

	//Measure current number of cities in which the array size is determined
	if (sizeOfArray.is_open())
	{

		string line;
		while (esc == 0)
		{

			getline(sizeOfArray, line);
			stringstream notData(line);
			string blank;
			getline(notData, blank, ',');

			if (blank == "[Cities]")
			{
				esc = 1;
			}
			if (loadTime == 200)
			{
				//errorLoad();
			}
			loadTime++;
		}
		while (getline(sizeOfArray, line))
		{

			stringstream det(line);
			string estTerr;
			getline(det, estTerr, ',');
			if (estTerr != "")
			{
				count++;
				arraySize.push_back(estTerr);
			}

		}
	}
	sizeOfArray.close();
	City t[size] = {};


	//Stores City names in array
	ifstream terNames(inputFile);
	if (terNames.is_open())
	{
		int i = 0;
		string line;
		esc = 0;


		while (esc == 0)
		{
			getline(terNames, line);
			stringstream notData(line);
			string blank;
			getline(notData, blank, ',');

			if (blank == "[Cities]")
			{

				esc = 1;
			}

		}

		while (getline(terNames, line))
		{
			stringstream ss1(line);
			string estTerr;
			getline(ss1, estTerr, ',');
			if (estTerr != "")
			{
				t[i] = City(estTerr, "null", 0, 0, 0, h);
				i++;
			}
		}
	}
	terNames.close();

	//This will allow the program to establish the edges of each City.
	Map PowerGrid;

	City* tp[size];

	for (int i = 0; i < size; i++)
	{
		tp[i] = &t[i];
	}
	ifstream last(inputFile);

	//Having each name of the city stored, we can now find out what data the city has regarding to its cost and its edges to other cities by opening the file one last time.
	if (last.is_open())
	{
		int i = 0;
		string line;
		esc = 0;

		while (esc == 0)
		{
			getline(last, line);
			stringstream notData(line);
			string blank;
			getline(notData, blank, ',');

			if (blank == "[Cities]")
			{
				esc = 1;
			}

		}

		while (getline(last, line))
		{
			stringstream ss(line);
			string city, color, c1, c2, c3;

			getline(ss, city, ',');
			getline(ss, color, ',');
			getline(ss, c2, ',');
			getline(ss, c3, ',');


			stringstream convert(c1);
			int iNum1 = 0;
			convert >> iNum1;
			stringstream convert1(c2);
			int iNum2 = 0;
			convert1 >> iNum2;
			stringstream convert2(c3);
			int iNum3 = 0;
			convert2 >> iNum3;
			if (city != "")
			{
				t[i] = City(city, color, iNum1, iNum2, iNum3, h);

				vector<string> connection;
				string cityConnect;
				while (getline(ss, cityConnect, ','))
				{
					connection.push_back(cityConnect);
					for (int z = 0; z < size; z++)
					{
						if (cityConnect == t[z].getName())
						{

							string cost;
							getline(ss, cost, ',');
							stringstream convert3(cost);
							int iNum4 = 0;
							convert3 >> iNum4;
							t[i].createConnection(tp[z], iNum4);
							z = size + 1;
						}

					}
				}
				if (city == "")
				{
					i--;
				}
				i++;
			}
		}
	}
	last.close();

	//Establishes connection points
	for (int i = 0; i < size; i++)
	{
		tp[i] = &t[i];
	}
	//Each City is placed on the map and are connected
	for (int j = 0; j < size; j++)
	{
		PowerGrid.create(tp[j]);
	}
	//Error check for duplicates
	for (int i = 0; i < 50; i++)
	{
		for (int j = 0; j < 50; i++)
		{
			if (i == j)
			{
				j++;
			}

			if (tp[i]->getName() == tp[j]->getName() && tp[i]->getName() != "")
			{
				//errorLoad();
			}
		}
	}
	//Displays loaded map


	//User Interaction
	cout << "1. Print whole map" << endl;
	cout << "2. Load map" << endl;
	cout << "3. Place house onto map" << endl;
	cout << "4. Create player and check their resources and cities owned." << endl;
	cout << "5. Check cards (powerplant cards, summary, step 3" << endl;
	int choice;
	cin >> choice;

	if (choice == 1)
	{
		PowerGrid.printMap();
		cout << "How many players will be player this game?(2 minimum, 6 maximum)" << endl;
		int numberOfPlayers;
		cin >> numberOfPlayers;

		while (numberOfPlayers < 1 || numberOfPlayers>6)
		{
			cout << "Please enter a valid range for the number of players. (2-6 players)" << endl;
			cin >> numberOfPlayers;
		}
		vector<Player> p;
		if (numberOfPlayers == 2)
		{
			Player p1;
			p1.setPlayerTurn(1);
			Player p2;
			p2.setPlayerTurn(2);
			p.push_back(p1);
			p.push_back(p2);
		}
		City c1("purple");
		City c2("yellow");
		City c3("brown");
		City c4("teal");
		City c5("red");
		City c6("green");

		City* cp1;City* cp2;City* cp3;City* cp4;City* cp5;City* cp6;
		cp1 = &c1;cp2 = &c2;cp3 = &c3;cp4 = &c4; cp5 = &c5;cp6 = &c6;
		c1.createConnection(cp2, 0);c1.createConnection(cp4, 0);c1.createConnection(cp5, 0);
		c2.createConnection(cp1, 0);c2.createConnection(cp3, 0);c2.createConnection(cp5, 0);c2.createConnection(cp6, 0);
		c3.createConnection(cp2, 0);c3.createConnection(cp6, 0);
		c4.createConnection(cp1, 0);c4.createConnection(cp5, 0);
		c5.createConnection(cp1, 0);c5.createConnection(cp2, 0);c5.createConnection(cp4, 0);c5.createConnection(cp6, 0);
		c6.createConnection(cp2, 0);c6.createConnection(cp3, 0);c6.createConnection(cp5, 0);
		Map minimap;
		minimap.create(cp1);minimap.create(cp2);minimap.create(cp3);minimap.create(cp4);minimap.create(cp5);minimap.create(cp6);
		minimap.printMap();
		
			cout << "Select an area to start player " << p[0].getTurnOrder() << endl;
			PowerGrid.printRegion();

			cout << "Choose a region to begin." << endl;
			cout << "1. Purple" << endl;cout << "2. Yellow" << endl;cout << "3. Brown" << endl;cout << "4. Teal" << endl;cout << "5. Red" << endl;cout << "6. Green" << endl;
			int regionChoice;
			cin >> regionChoice;
			if (regionChoice == 1){p[0].setStartRegion("purple");}
			if (regionChoice == 2){p[0].setStartRegion("yellow");}
			if (regionChoice == 3){p[0].setStartRegion("brown");}
			if (regionChoice == 4){p[0].setStartRegion("teal");}
			if (regionChoice == 5){p[0].setStartRegion("red");}
			if (regionChoice == 6){p[0].setStartRegion("green");}

			cout << "Select an area to start player " << p[1].getTurnOrder() << endl;
			cout << "Choose a region to begin." << endl;
			cout << "1. Purple" << endl;cout << "2. Yellow" << endl;cout << "3. Brown" << endl;cout << "4. Teal" << endl;cout << "5. Red" << endl;cout << "6. Green" << endl;
			int x=1;
			while(x!=0)
			{ 
				cin >> regionChoice;
				if (regionChoice == 1 && (p[0].getStartRegion()=="purple" || p[0].getStartRegion() == "yellow" || p[0].getStartRegion() == "red" || p[0].getStartRegion() == "teal"))
				{ 
					p[1].setStartRegion("purple");
					x = 0;
				}
				else if (regionChoice == 2 && (p[0].getStartRegion() == "purple" || p[0].getStartRegion() == "yellow" || p[0].getStartRegion() == "red" || p[0].getStartRegion() == "green" || p[0].getStartRegion()=="brown"))
				{
					p[1].setStartRegion("yellow");
					x = 0;
				}
				else if (regionChoice == 3 && (p[0].getStartRegion() == "brown" || p[0].getStartRegion() == "yellow" || p[0].getStartRegion() == "green"))
				{
					p[1].setStartRegion("brown");
					x = 0;
				}
				else if (regionChoice == 4 && (p[0].getStartRegion() == "purple" || p[0].getStartRegion() == "red" || p[0].getStartRegion() == "teal"))
				{
					p[1].setStartRegion("teal");
					x = 0;
				}
				else if (regionChoice == 5 && (p[0].getStartRegion() == "purple" || p[0].getStartRegion() == "yellow" || p[0].getStartRegion() == "red" || p[0].getStartRegion() == "teal" || p[0].getStartRegion()=="green"))
				{
					p[1].setStartRegion("red");
					x = 0;
				}
				else if (regionChoice == 6 && (p[0].getStartRegion() == "brown" || p[0].getStartRegion() == "yellow" || p[0].getStartRegion() == "red" || p[0].getStartRegion() == "green"))
				{

					p[1].setStartRegion("green");
					x = 0;
				}
				else
				{
					cout << "Invalid region. Choose one that is adjacent to another player." << endl;
				}
			}
			//Dividing market cards and removing cards from deck total.
			Card ppc;
			Card actualMarketCard;
			Card futureMarketCard;
			actualMarketCard.clearVector();
			futureMarketCard.clearVector();

			actualMarketCard.addElement(*ppc.getSet(0));
			actualMarketCard.addElement(*ppc.getSet(1));
			actualMarketCard.addElement(*ppc.getSet(2));
			actualMarketCard.addElement(*ppc.getSet(3));
			futureMarketCard.addElement(*ppc.getSet(4));
			futureMarketCard.addElement(*ppc.getSet(5));
			futureMarketCard.addElement(*ppc.getSet(6));
			futureMarketCard.addElement(*ppc.getSet(7));
			
			ppc.eraseElement(3);ppc.eraseElement(4);ppc.eraseElement(5);ppc.eraseElement(6);ppc.eraseElement(7);ppc.eraseElement(8);


			cout << "Each player has chosen their region. The game will now begin." << endl;

			
			
			int mainGameLoop = 0;

			while (mainGameLoop == 0)
			{
				//Phase 1: Determine player order
				if (p[0].getCurrentTurn() == p[1].getCurrentTurn())
				{
					int randomNum;
					srand(time(NULL));
					randomNum = rand() % 10 + 1;
					if (randomNum % 2 == 0)
					{
						p[0].setCurrentTurn(1);
						p[1].setCurrentTurn(2);
						cout << "Player order is determined." << endl;
					}
					else
					{
						p[0].setCurrentTurn(2);
						p[1].setCurrentTurn(1);
						cout << "Player order is determined." << endl;
					}
					
				}
				//Phase 2: Auction
				//cout << "Auction Power Plant has begun.";
				int myCost=0;
				int z;
				int i = 0;
				int j = 0;
				
				int exit = 9;
				//for (int i = 0; i <= 2 || exit==9; i++)
				//{
					while(exit ==9)//for (int j = 0; j <= 2 || exit==9; j++)
					{
						if (p[i].getCurrentTurn() < p[j].getCurrentTurn())
						{
							cout << "Player " << p[i].getTurnOrder() << " will begin the auction phase." << endl;
							actualMarketCard.displayPowerPlantCards();
							cout << "Choose a card which you wish to bid for. Or you can pass by typing '99'" << endl;
							int choose;
							cin >> choose;
							int bid = 1;

							if (choose == 99)
							{
								p[i].pass();
							}
							else
							{
								int x = 0;
								for (z = 0; z < actualMarketCard.sizeOfSet() && x !=-1; z++)
								{
									if (choose == actualMarketCard.getSet(z)->getNumber())
									{
										cout << "You have made a bid on Card " << actualMarketCard.getSet(z)->getNumber() << ", of elektro cost of " << actualMarketCard.getSet(z)->getNumber() << endl;
										actualMarketCard.getSet(z)->setToPlayer(i);
										bid = 0;
										x = -1;

									}
								}
								
							}
							
							while (bid == 0)
							{
								cout << "Would player " << p[j].getTurnOrder() << " like to make a bid?" << endl;
								cin >> choose;
								if (choose != 99 && p[j].getPassVal()!=0)
								{
									cout << "The bid you place must be higher then the last price" << endl;

									cin >> myCost;

									if (myCost > actualMarketCard.getSet(z)->getNumber());
									{
										actualMarketCard.getSet(z)->setToPlayer(j);
									}
									
								}
								else
								{
									p[j].pass();
									bid = -1;

									if (j == 0)
									{
										p[1].setMyMoney(p[1].getMyMoney() - myCost);
									}
									else
									{
										p[0].setMyMoney(p[0].getMyMoney() - myCost);
									}
								}
								if (j >= p.size())
								{
									j = 0;
								}
								else
								{
									j++;
								}
							}
						}
						else
						{
							cout << "Player " << p[i].getTurnOrder() << " will begin the auction phase." << endl;
							actualMarketCard.displayPowerPlantCards();
							cout << "Choose a card which you wish to bid for. Or you can pass by typing '99'" << endl;
							int cardNum;
							cin >> cardNum;
							int bid = 1;

							if (cardNum == 99)
							{
								p[i].pass();
							}
							else
							{
								int x = 0;
								for (z = 0; z < actualMarketCard.sizeOfSet() && x != -1; z++)
								{
									if (cardNum == actualMarketCard.getSet(z)->getNumber())
									{
										cout << "You have made a bid on Card " << actualMarketCard.getSet(z)->getNumber() << ", of elektro cost of " << actualMarketCard.getSet(z)->getNumber() << endl;
										actualMarketCard.getSet(z)->setToPlayer(i);
										cout << z << endl;
										bid = 0;
										x = -1;

									}
								}

							}

							while (bid == 0)
							{
								int choice;
								cout << "Would player " << p[j].getTurnOrder() << " like to make a bid? Or pass (99)" << endl;
								cin >> choice;
								if (choice != 99 && p[j].getPassVal() != 0)
								{
									cout << "The bidz you place must be higher then the last price" << endl;

									cin >> myCost;
									
									if (myCost >= actualMarketCard.getSet(z)->getNumber())
									{
										actualMarketCard.getSet(z)->setToPlayer(j);
										
									}
									else
									{
										cout << "You have bid less then the previous player. You lost the auction." << endl;
										p[j].pass();
										bid = -1;

										if (j == 0)
										{
											p[1].setMyMoney(p[1].getMyMoney() - myCost);
											p[1].addCard(*actualMarketCard.getSet(z));
										}
										else
										{
											p[0].setMyMoney(p[0].getMyMoney() - myCost);
											p[0].addCard(*actualMarketCard.getSet(z));
										}
										actualMarketCard.eraseElement(cardNum);
										
									}
									

								}
								else
								{
									p[j].pass();
									bid = -1;

									if (j == 0)
									{
										p[1].setMyMoney(p[1].getMyMoney() - myCost);
										p[1].addCard(*actualMarketCard.getSet(z));
									}
									else
									{
										p[0].setMyMoney(p[0].getMyMoney() - myCost);
										p[0].addCard(*actualMarketCard.getSet(z));
									}
									actualMarketCard.eraseElement(cardNum);
									
								}
								if (j >= p.size()-1)
								{
									j = 0;
								}
								else
								{
									j++;
								}
							}
						}
						cout << "made it" << endl;
						exit = 10;
					}
				//}
				
				

				
			}


	
	}
	//PART 3, phase 3 and 4
	else if (choice == 2)
	{
		//Example player pool used  for demo.
		
		Player p1, p2, p3;
		vector<Player> p;
		p.push_back(p1);p.push_back(p2);p.push_back(p3);
		p[0].setCurrentTurn(0);p[1].setCurrentTurn(2);p[2].setCurrentTurn(1);
		p[0].setPlayerTurn(1);p[1].setPlayerTurn(2);p[2].setPlayerTurn(3);
		p[0].setStartRegion("purple");p[1].setStartRegion("yellow");p[2].setStartRegion("teal");
		PowerGrid.setCityForPlayer(p[0], "purple");PowerGrid.setCityForPlayer(p[1], "yellow");PowerGrid.setCityForPlayer(p[2], "teal");
		//The players will also be assigned power plant cards for demonstration purposes.
		Card ppc;
		Card actualMarketCard;
		Card futureMarketCard;
		actualMarketCard.clearVector();
		futureMarketCard.clearVector();

		actualMarketCard.addElement(*ppc.getSet(0));
		actualMarketCard.addElement(*ppc.getSet(1));
		actualMarketCard.addElement(*ppc.getSet(2));
		actualMarketCard.addElement(*ppc.getSet(3));
		futureMarketCard.addElement(*ppc.getSet(4));
		futureMarketCard.addElement(*ppc.getSet(5));
		futureMarketCard.addElement(*ppc.getSet(6));
		futureMarketCard.addElement(*ppc.getSet(7));
		ppc.eraseElement(3);ppc.eraseElement(4);ppc.eraseElement(5);ppc.eraseElement(6);ppc.eraseElement(7);ppc.eraseElement(8);
		
		p[0].clearCard();p[1].clearCard();p[2].clearCard();
		
		p[0].addCard(*actualMarketCard.getSet(0));
		
		p[1].addCard(*actualMarketCard.getSet(1));
		
		p[2].addCard(*actualMarketCard.getSet(2));
		
		actualMarketCard.eraseElement(0/*actualMarketCard.getSet(0)->getNumber()*/);
		actualMarketCard.eraseElement(1/*actualMarketCard.getSet(1)->getNumber()*/);
		actualMarketCard.eraseElement(2/*actualMarketCard.getSet(2)->getNumber()*/);
		cout << "here" << endl;
		
		int loop = 0;
		int checkTurnOrder = 0;
		int reverseOrder = p.size()-1;
		//THIS IS THE BUYING RESOURCE PHASE.
		while (loop == 0)
		{
			if (p[checkTurnOrder].getCurrentTurn() == reverseOrder)
			{
				
				//Buying Resources phase.
				cout << "Would Player " << p[checkTurnOrder].getTurnOrder() << ", like to buy any resources for their select properties?" << endl;
				cout << p[checkTurnOrder].getCardTotal() << endl;
				p[checkTurnOrder].displayMyCards();
				//cout<< "Your resources will be listed below." << endl;
				//p[checkTurnOrder].displayMyResources();
				cout << "Type the card number in which you want to buy resources for." << endl;

				int cardChoice;
				cin >> cardChoice;

				p[checkTurnOrder].setResourcesOnCard(cardChoice);
				
				//for (int pr = 0; pr < p[checkTurnOrder].getCardTotal(); pr++)
				//{

				//}
				reverseOrder--;
			}
			checkTurnOrder++;
			if (checkTurnOrder >= p.size())
			{
				checkTurnOrder = 0;
			}
			if (reverseOrder == -1)
			{
				loop = 1;
			}
		}
		loop = 0;
		checkTurnOrder = 0;
		reverseOrder = p.size() - 1;
		//THIS IS THE HOUSING PHASE
		while (loop == 0)
		{
			if (p[checkTurnOrder].getCurrentTurn() == reverseOrder)
			{
			
				//This if statement is for starting games when choosing the first city.
				if(p[checkTurnOrder].getMyHouses() == 22)
				{ 
					//Housing phase.
					cout << "Would Player " << p[checkTurnOrder].getTurnOrder() << ", like to build any houses in the city of their color" << endl;
					cout << "These are the cities in which you can start in." << endl;
					PowerGrid.displayColorCity(p[checkTurnOrder].getStartRegion());
					cout << "Pick a city in which you will start in by typing its name. (Example: Seattle)" << endl;
					string cityChoice;
					cin >> cityChoice;

					int cost = PowerGrid.setCityForPlayer(p[checkTurnOrder], cityChoice);
					if (cost == 0)
					{
						cout << "City has no houses to place." << endl;
					}
					else if (cost == 1)
					{
						cout << "House has been placed at a spot open for 10 elektro" << endl;
						p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() - 10);
						p[checkTurnOrder].setMyHouses(p[checkTurnOrder].getMyHouses() - 1);
					}
					else if (cost == 2)
					{
						cout << "House has been placed at a spot open for 15 elektro" << endl;
						p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() - 15);
						p[checkTurnOrder].setMyHouses(p[checkTurnOrder].getMyHouses() - 1);
					}
					else
					{
						cout << "House has been placed at a spot open for 20 elektro" << endl;
						p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() - 20);
						p[checkTurnOrder].setMyHouses(p[checkTurnOrder].getMyHouses() - 1);
					}
					reverseOrder--;
				}
				else
				{
					//Housing phase.
					cout << "Would Player " << p[checkTurnOrder].getTurnOrder() << ", like to build any new houses" << endl;
					PowerGrid.printMap();
					cout << "\nHere is a map of neighbouring cities around your currently owned cities." << endl;
					PowerGrid.checkMyCity(p[checkTurnOrder]);
					cout << "Choose a city in which you would like to establish a new house" << endl;
					string newCity;
					cin >> newCity;
					cout << "Choose a city in which you already own" << endl;
					string myCity;
					cin >> myCity;

					int costForNewCity = PowerGrid.ownNewCity(p[checkTurnOrder], newCity, myCity);

					if (costForNewCity == -1)
					{
						cout << "No available housing is left on that city" << endl;
					}
					else
					{
						PowerGrid.setCityForPlayer(p[checkTurnOrder], newCity);
						p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() - costForNewCity);
					}
					reverseOrder--;
				}
				
			}
			checkTurnOrder++;
			if (checkTurnOrder >= p.size())
			{
				checkTurnOrder = 0;
			}
			if (reverseOrder == -1)
			{
				loop = 1;
			}
		}
		//Part 4, phase 5

		int normalOrder = 0;
		loop = 0;
		checkTurnOrder = 0;
		while (loop == 0)
		{
			if (p[checkTurnOrder].getCurrentTurn() == normalOrder)
			{
				cout << "Does player " << p[checkTurnOrder].getCurrentTurn() << " wish to supply electricity to their city?" << endl;
				int decision;
				cout << "1. Yes" << endl;
				cout << "2. No" << endl;
				cin >> decision;

				if (decision == 1)
				{
					int myCityTotal = PowerGrid.countTotalCityForPlayer(p[checkTurnOrder]);
					cout << "You own " << myCityTotal << " on the map." << endl;

					cout << "You can provide electricity for up to, " << p[checkTurnOrder].determineHousePower() << " cities." << endl;
					cout << "How many cities do you wish to provide electricity to?" << endl;
					

					int invalidDecision = 0;
					while (invalidDecision == 0)
					{
						cin >> decision;
						if (decision<0 || decision > myCityTotal)
						{
							cout << "Enter valid range." << endl;
						}
						else
						{
							invalidDecision = -1;
						}
					}
					cout << "You are providing electricity to " << decision << " cities. You must remove resources to provide sufficient electricity" << endl;
					p[checkTurnOrder].removeResources(decision);

					if (decision == 0) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 10); }
					if (decision == 1) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 22); }
					if (decision == 2) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 33); }
					if (decision == 3) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 44); }
					if (decision == 4) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 54); }
					if (decision == 5) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 64); }
					if (decision == 6) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 73); }
					if (decision == 7) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 82); }
					if (decision == 8) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 90); }
					if (decision == 9) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 98); }
					if (decision == 10) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 105); }
					if (decision == 11) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 112); }
					if (decision == 12) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 118); }
					if (decision == 13) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 124); }
					if (decision == 14) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 129); }
					if (decision == 15) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 134); }
					if (decision == 16) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 138); }
					if (decision == 17) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 142); }
					if (decision == 18) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 145); }
					if (decision == 19) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 148); }
					if (decision == 20) { p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 150); }

				}
				else
				{
					cout << "You have not supplied any electricity to any of your cities. 10 Elektro will be provided to you." << endl;
					p[checkTurnOrder].setMyMoney(p[checkTurnOrder].getMyMoney() + 10);
				}

				normalOrder++;
			}
			else
			{
				checkTurnOrder++;
				if (checkTurnOrder >= p.size())
				{
					checkTurnOrder = 0;
				}
				if (normalOrder >= p.size())
				{
					loop = 1;
				}
			}

		}
		//Resupplying the Resource Market
		cout << "Resupplying market. . . Done!" << endl;
		PowerGrid.resupply(p.size());

		//Updating PowerPlant Market
		int compare = 0;
		for (int j = 0; futureMarketCard.sizeOfSet(); j++)
		{
			if (futureMarketCard.getSet(compare)->getNumber() < futureMarketCard.getSet(j)->getNumber())
			{
				compare = j;
			}
		}
		actualMarketCard.addElement(*futureMarketCard.getSet(compare));
		futureMarketCard.eraseElement(futureMarketCard.getSet(compare)->getNumber());
		ppc.Shuffle();
		futureMarketCard.addElement(*ppc.getSet(0));
		
	
		
		/*cout << "Enter file name." << endl;
		string name="Cities.txt";
		Map PowerGrid;
		PowerGrid.loadMap(name);

		cout << "How many players will be player this game?(2 minimum, 6 maximum)" << endl;
		int numberOfPlayers;
		cin >> numberOfPlayers;

		while (numberOfPlayers < 1 || numberOfPlayers>6)
		{
			cout << "Please enter a valid range for the number of players. (2-6 players)" << endl;
			cin >> numberOfPlayers;
		}
		vector<Player> p;
		if (numberOfPlayers == 2)
		{
			Player p1;
			p1.setPlayerTurn(1);
			Player p2;
			p2.setPlayerTurn(2);
			p.push_back(p1);
			p.push_back(p2);
		}
		City c1("purple");
		City c2("yellow");
		City c3("brown");
		City c4("teal");
		City c5("red");
		City c6("green");
		
		City* cp1;City* cp2;City* cp3;City* cp4;City* cp5;City* cp6;
		cp1 = &c1;cp2 = &c2;cp3 = &c3;cp4 = &c4; cp5 = &c5;cp6 = &c6;
		c1.createConnection(cp2, 0);c1.createConnection(cp4, 0);c1.createConnection(cp5, 0);
		c2.createConnection(cp1, 0);c2.createConnection(cp3, 0);c2.createConnection(cp5, 0);c2.createConnection(cp6, 0);
		c3.createConnection(cp2, 0);c3.createConnection(cp6, 0);
		c4.createConnection(cp1, 0);c4.createConnection(cp5, 0);
		c5.createConnection(cp1, 0);c5.createConnection(cp2, 0);c5.createConnection(cp4, 0);c5.createConnection(cp6, 0);
		c6.createConnection(cp2, 0);c6.createConnection(cp3, 0);c6.createConnection(cp5, 0);
		Map minimap;
		minimap.create(cp1);minimap.create(cp2);minimap.create(cp3);minimap.create(cp4);minimap.create(cp5);minimap.create(cp6);
		cout << "Select an area to start player " << p[0].getTurnOrder() << endl;
		PowerGrid.printMap();*/
	}
	//PART 4, phase 5
	else if (choice == 3)
	{
		/*Player p1, p2, p3;
		vector<Player> p;
		p.push_back(p1);p.push_back(p2);p.push_back(p3);
		p[0].setCurrentTurn(0);p[1].setCurrentTurn(2);p[2].setCurrentTurn(1);
		p[0].setPlayerTurn(1);p[1].setPlayerTurn(2);p[2].setPlayerTurn(3);
		PowerGrid.setCityForPlayer(p[0], "Seattle"); PowerGrid.setCityForPlayer(p[0], "Phoenix"); PowerGrid.setCityForPlayer(p[1],"Chicago");
		int normalOrder = 0;
		int loop = 0;
		int checkTurnOrder = 0;
		while (loop == 0)
		{
			if (p[checkTurnOrder].getCurrentTurn() == normalOrder)
			{

				normalOrder++;
			}
			else
			{
				checkTurnOrder++;
				if (checkTurnOrder >= p.size())
				{
					checkTurnOrder = 0;
				}
				if (normalOrder>= p.size())
				{
					loop = 1;
				}
			}
			
		}*/
		/*Player p(2);
		cout << "Where would you like to place a house?" << endl;
		PowerGrid.printMap();
		int placement;
		cin >> placement;

		if (p.getMyHouses() > 0)
		{
			if (t[placement].getCost1() >= 15)
			{
				//t[placement].setHouses(p);
		
			}
		}
		PowerGrid.printMap();*/
	}
	/*else if (choice == 4)
	{
		Player newPlayer(1);
		t[0].setHouses(newPlayer);
		t[4].setHouses(newPlayer);
		t[12].setHouses(newPlayer);
		cout << "Player " << newPlayer.getTurnOrder() << " current stats" << endl;
		newPlayer.displayMyHouses();
		newPlayer.displayMyResources();
		newPlayer.displayMyMoney();
		cout << "Player " << newPlayer.getTurnOrder() << " owns: " << endl;
		for (int i = 0; i < 42; i++)
		{

			if (newPlayer.getTurnOrder() == t[i].getPlayerNum())
			{
				cout << t[i].getName() << endl;
			}
		}
		
	}
	else if (choice == 5)
	{
		Card c;
		c.displayPowerPlantCards();
	
	}*/
	system("pause");
	return 1;

}



